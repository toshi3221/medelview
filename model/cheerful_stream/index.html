<html>
<meta charset="utf-8">
	<style>
		html, body { height:100%; overflow:hidden; }
		body { margin:0; }
		#snapshot { position: absolute; top: 0px; left: 0px; }
	</style>
<body>
<script src="jquery.min.js"></script>
<script src="dat.gui.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<script src="charsetencoder.min.js"></script>
<script src="ammo.js"></script>
<script src="TGALoader.js"></script>
<script src="MMDLoader.js"></script>
<script src="CCDIKSolver.js"></script>
<script src="MMDPhysics.js"></script>
<script src="Stats.js"></script>
<script>

$(init);

var SceneParams = function() {
  // Camera
  // teramemo camera must move
  this.cameraFov = 60;
  this.cameraX = -15;
  this.cameraY = 0;
  this.cameraZ = 18;
  // Light
  this.lightIntensity = 0;
  this.lightX = 100;
  this.lightY = 100;
  this.lightZ = -100;
  this.lightColor = "#ffffff";
  this.lightCastShadow = false;
  // Light2
  this.light2Intensity = 0.2;
  this.light2X = -100;
  this.light2Y = 100;
  this.light2Z = -100;
  this.light2Color = "#ffffff";
  this.light2CastShadow = false;
  // Light3
  this.light3Intensity = 0;
  this.light3X = -5;
  this.light3Y = 150;
  this.light3Z = 200;
  this.light3Color = "#ffffff";
  this.light3CastShadow = true;
  // AmbientLight
  this.ambientLightColor = "#cccccc";
  // Object
  this.objectX = -0.25;
  this.objectY = -16.0;
  this.objectZ = 0.0;
  this.objectScale = 5.7;
  // Sphere
  this.sphereRotation = 0;
  // Operation
  this.stop = function () {
    action.stop();
    $audio.get(0).pause();
  };
  this.start = function () {
    action.stop();
    $audio.get(0).load();
    action.play();
    $audio.get(0).play();
  };
};

var ready = false;
var helper;
var ikSolver;
var camZ = 0;
var camZ_max = 1000;
var camZ_min = 100;
var segmentNumber = 60;
var camera_size = null;
var uvc_blender = false;
var show_stats = false;
var canvas_size = null;
function init() {
    // クエリチェック
   var url_vars =  getUrlVars();
   if (url_vars["cm"]) {
     camera_size = parseInt(url_vars["cm"]);
   }
   if ("ub" in url_vars) {
     uvc_blender = true;
   }
   if ("st" in url_vars) {
     show_stats = true;
   }
   if (url_vars["cv"]) {
     canvas_size = parseInt(url_vars["cv"]);
   }

	var sp = new SceneParams();

                // FPS表示
                stats = new Stats();
                var $stats = $(stats.domElement);
                stats.setMode( 0 ); //fps
                // align top-left
                $stats.css({
                        position: "absolute",
                        left: "80px",
                        top: 0
                        });

                if (show_stats) {
                    $("body").append($stats);
                }


    scene = new THREE.Scene();
  
    clock = new THREE.Clock();
	var width = $(window).width();
    var height = $(window).height();

    // カメラ
    camera = new THREE.PerspectiveCamera( sp.cameraFov, width / height);
	camera.position.x = sp.cameraX;
	camera.position.y = sp.cameraY;
    camera.position.z = sp.cameraZ;
    scene.add( camera );

     
    //ライティング
    light = new THREE.DirectionalLight( eval(sp.lightColor.replace('#','0x')), sp.lightIntensity );
    light.position.set(sp.lightX,sp.lightY,sp.lightZ);
	light.castShadow = sp.lightCastShadow; //影を落とす光にする
	light.shadow.mapSize.width = 2048; //影のマッピング細かさ
	light.shadow.mapSize.height = 2048; //影のマッピング細かさ
    scene.add( light );
    light2 = new THREE.DirectionalLight( eval(sp.light2Color.replace('#','0x')), sp.light2Intensity );
    light2.position.set(sp.light2X,sp.light2Y,sp.light2Z);
	light2.castShadow = sp.light2CastShadow; //影を落とす光にする
	light2.shadow.mapSize.width = 2048; //影のマッピング細かさ
	light2.shadow.mapSize.height = 2048; //影のマッピング細かさ
	scene.add( light2 );
	light3 = new THREE.DirectionalLight( eval(sp.light3Color.replace('#','0x')), sp.light3Intensity );
    light3.position.set(sp.light3X,sp.light3Y,sp.light3Z);
	light3.castShadow = sp.light3CastShadow; //影を落とす光にする
	light3.shadow.mapSize.width = 2048; //影のマッピング細かさ
	light3.shadow.mapSize.height = 2048; //影のマッピング細かさ
    scene.add( light3 );
	ambientLight = new THREE.AmbientLight( eval(sp.ambientLightColor.replace('#','0x')) );
    scene.add(ambientLight); //環境光
     
    //レンダラー
    renderer = new THREE.WebGLRenderer();//THREE.CanvasRenderer();でもいいけどポリゴンの裏が非表示？

    //オブジェクト
    helper = new THREE.MMDHelper( renderer );
    loader = new THREE.MMDLoader();
    var modelFile = 'models/lat/miku.pmd'
    var vmdFiles = ['fight.vmd'];
    loader.load( modelFile, vmdFiles, function ( object ) {
		json = object;
        json.position.set( sp.objectX, sp.objectY, sp.objectZ); //オブジェクトの位置
        json.overdraw = true;
        json.castShadow = true; //影を作るオブジェクト対象(castだけでは自身に影はつかない) MMDLoaderはshadowをまだサポートしていない
        helper.add( json );
        helper.setAnimation( json );
        helper.setPhysics( json );


		//背景
  		navigator.getMedia = ( navigator.getUserMedia ||
                       navigator.webkitGetUserMedia ||
                       navigator.mozGetUserMedia ||
                       navigator.msGetUserMedia);
  		var is_ff = navigator.mozGetUserMedia;
 		 video = document.createElement('video');
  		var camera_height = camera_size || 1080;
  		var camera_width = uvc_blender ? camera_height*2 : (camera_size || 1080) * 1920 / 1080;
		navigator.getMedia( {"video": is_ff ? { height: { ideal: camera_height } } : {mandatory: { minWidth: camera_width, maxWidth: camera_width, minHeight: camera_height, maxHeight: camera_height }}, "audio":true}, function(stream){
       	video.src = URL.createObjectURL(stream);
        window.localStream = stream;
        video.play();
        videoImage = document.createElement('canvas');
        videoImageContext = videoImage.getContext('2d');
        videoImageContext.fillStyle = '#000000';
        tex = new THREE.Texture(videoImage);
	    tex.minFilter = tex.magFilter = THREE.LinearFilter;
        sphereGeometry = new THREE.SphereGeometry( 18, segmentNumber, segmentNumber); // MMDLoader側のスケールが今のところ変えられない
        var matrix = new THREE.Matrix4().makeScale(1, 1, -1);
        sphereGeometry.applyMatrix(matrix);
        lastSphereRotation = sp.sphereRotation;
        var sphereRotationY = new THREE.Matrix4().makeRotationY((90+sp.sphereRotation) * Math.PI/180.0);
        sphereGeometry.applyMatrix(sphereRotationY);
        mesh = new THREE.Mesh(sphereGeometry , new THREE.MeshBasicMaterial( { map: tex, overdraw: true} ) );
	    mesh.receiveShadow = true; //影を受けるオブジェクト対象(receiveだけでは自身は影を作らない)
        scene.add( mesh );

        var audioParams = { delayTime: 0 };
        loader.loadAudio( 'muni.m4a', function ( audio, listener ) {

                listener.position.z = 1;

                helper.setAudio( audio, listener, audioParams );

                /*
                 * Note: call this method after you set all animations
                 *       including camera and audio.
                 */
                helper.unifyAnimationDuration();

                scene.add( audio );
                scene.add( listener );
//		scene.add( json );

		ready = true;
                animate();

        }, function(xhr) {}, function(xhr) {} );

    }, function(error) {
          console.log("The following error occured: " + error);
    });

    });

    //レンダラー
    var aspect = width/height;
    var renderer_height = canvas_size || height;
    renderer.setSize( renderer_height*aspect, renderer_height );
    var renderer_element = renderer.domElement;
    renderer_element.style.width = width + "px";
    renderer_element.style.height = height + "px";
    renderer.shadowMap.enabled = true;
    document.body.appendChild( renderer.domElement );
  
    //マウスコントローラ
    control = new THREE.OrbitControls( camera, renderer.domElement ); // 表示領域をコントロール
    control.noPan = true; // 右ドラッグ(平行視点移動禁止)

    //key bind
    keyEventOn();

}
var moving_interval = 100/30;
var ctrl;
function keyEventOn() {
  var $window = $(window);
  var press_key = null;
  var visible_miku = false;
  var element = control.domElement === document ? control.domElement.body : control.domElement;
  var rotateDelta = 1.01;
  var rotateDeltaMax = 3.0;

  $window.keydown(function(e) {
    if (press_key == e.keyCode) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    clearInterval(ctrl);
    rotateDelta = 1.01;
    switch (e.keyCode) {
      case 13: // Enter
        press_key = e.keyCode;
        if (visible_miku) {
          scene.remove(json);
          visible_miku = false;
        } else {
          visible_miku = true;
          json.mixer.clipAction(json.geometry.animations[0]).time = 0;
          scene.add(json);
        }
        break;
      case 33: // Page Up
        press_key = e.keyCode;
        // zoom in
        break;
      case 34: // Page Down
        press_key = e.keyCode;
        // zoom out
        break;
      case 37: // Left
        press_key = e.keyCode;
        // look left
        ctrl = setInterval(function(){if(rotateDelta<rotateDeltaMax)rotateDelta*=rotateDelta; control.rotateLeft( 2 * Math.PI * rotateDelta / element.clientWidth * control.rotateSpeed );},moving_interval);
        break;
      case 38: // Up
        press_key = e.keyCode;
        // look up
        ctrl = setInterval(function(){control.rotateUp( 2 * Math.PI * rotateDelta / element.clientHeight * control.rotateSpeed );},moving_interval);
        break;
      case 39: // Right
        press_key = e.keyCode;
        // look right
        ctrl = setInterval(function(){if(rotateDelta<rotateDeltaMax)rotateDelta*=rotateDelta; control.rotateLeft( (-2) * Math.PI * rotateDelta / element.clientWidth * control.rotateSpeed );},moving_interval);
        break;
      case 40: // Down
        press_key = e.keyCode;
        // look down
        ctrl = setInterval(function(){control.rotateUp( (-2) * Math.PI * rotateDelta / element.clientHeight * control.rotateSpeed );},moving_interval);
        break;
    }
    if (press_key) {
      e.preventDefault();
      e.stopPropagation();
    }
  });
  $window.keyup(function(e) {
    switch (e.keyCode) {
      case 13: // Enter
      case 33: // Page Up
      case 34: // Page Down
      case 37: // Left
      case 38: // Up
      case 39: // Right
      case 40: // Down
        press_key = null;
        clearInterval(ctrl);
        break;
    }
  });
}


var isAudioInitialized = false;
var isVideoInitialized = false;
function animate() {
    requestAnimationFrame( animate );
    if (ready) {
	var delta = clock.getDelta();
        helper.animate(delta);
        helper.render( scene, camera );
    } else {
        renderer.clear();
        renderer.render( scene, camera );
    }
       if (video.readyState === video.HAVE_ENOUGH_DATA)  {
        video.play();
          if (!isVideoInitialized) {
            var width = video.videoWidth;
            var height = video.videoHeight;
            console.log("video-width: " + width + ", video-height: " + height);
            var equi_height = width/2 - 2;
            videoImage.width = width;
            videoImage.height = uvc_blender ? height : equi_height;
            videoImageContext = videoImage.getContext('2d');
            videoImageContext.fillRect(0, 0, width, height);
            isVideoInitialized = true;
          }
        videoImageContext.drawImage(video, 0, 0);
        tex.needsUpdate = true;
      }

    control.update();   //これ追加
    stats.update();
}

function getUrlVars()
{
    var vars = [], hash;
    var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for(var i = 0; i < hashes.length; i++) {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
}
</script>

</body>
</html>
